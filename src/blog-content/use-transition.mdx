# React 19's useTransition Hook

React 19 introduces the powerful `useTransition` hook, a game-changer for creating smooth, responsive user interfaces. This hook allows you to mark certain state updates as "transitions," enabling React to prioritize urgent updates while keeping non-urgent ones in the background.

## What is useTransition?

The `useTransition` hook is designed to help you manage state updates that might cause your UI to lag or feel unresponsive. By wrapping state updates in a transition, you tell React that these updates are less urgent and can be interrupted by more important updates.

```tsx
import { useTransition, useState } from "react";

function MyComponent() {
  const [isPending, startTransition] = useTransition();
  const [searchTerm, setSearchTerm] = useState("");
  const [results, setResults] = useState([]);

  const handleSearch = (term: string) => {
    setSearchTerm(term); // Urgent update
    startTransition(() => {
      // Non-urgent update that won't block the UI
      setResults(performExpensiveSearch(term));
    });
  };

  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => handleSearch(e.target.value)}
        placeholder="Search..."
      />
      {isPending && <div>Searching...</div>}
      <SearchResults results={results} />
    </div>
  );
}
```

## Key Benefits

### 1. **Improved Responsiveness**

The primary benefit is keeping your UI responsive during expensive operations. Without `useTransition`, heavy computations can block the main thread, making your app feel sluggish.

### 2. **Better User Experience**

Users get immediate feedback for their interactions while background processing happens seamlessly.

### 3. **Automatic Prioritization**

React automatically prioritizes urgent updates (like user input) over transition updates.

## Real-World Example: Live Search with Filtering

Here's a practical example of implementing a live search feature with filtering:

```tsx
import { useTransition, useState, useMemo } from "react";

interface Product {
  id: number;
  name: string;
  category: string;
  price: number;
}

function ProductSearch({ products }: { products: Product[] }) {
  const [isPending, startTransition] = useTransition();
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedCategory, setSelectedCategory] = useState("all");

  // Expensive filtering operation
  const filteredProducts = useMemo(() => {
    return products.filter((product) => {
      const matchesSearch = product.name
        .toLowerCase()
        .includes(searchQuery.toLowerCase());
      const matchesCategory =
        selectedCategory === "all" || product.category === selectedCategory;
      return matchesSearch && matchesCategory;
    });
  }, [products, searchQuery, selectedCategory]);

  const handleSearchChange = (query: string) => {
    setSearchQuery(query); // Immediate UI update

    startTransition(() => {
      // This triggers the expensive filtering
      // but won't block the input field
    });
  };

  const handleCategoryChange = (category: string) => {
    startTransition(() => {
      setSelectedCategory(category);
    });
  };

  return (
    <div className="space-y-4">
      <div className="flex gap-4">
        <input
          type="text"
          value={searchQuery}
          onChange={(e) => handleSearchChange(e.target.value)}
          placeholder="Search products..."
          className="flex-1 rounded-md border px-3 py-2"
        />

        <select
          value={selectedCategory}
          onChange={(e) => handleCategoryChange(e.target.value)}
          className="rounded-md border px-3 py-2"
        >
          <option value="all">All Categories</option>
          <option value="electronics">Electronics</option>
          <option value="clothing">Clothing</option>
          <option value="books">Books</option>
        </select>
      </div>

      {isPending && (
        <div className="flex items-center gap-2 text-blue-600">
          <div className="h-4 w-4 animate-spin rounded-full border-2 border-blue-600 border-t-transparent" />
          <span>Filtering products...</span>
        </div>
      )}

      <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3">
        {filteredProducts.map((product) => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>
    </div>
  );
}
```

## Best Practices

### 1. **Use for Non-Urgent Updates**

Only wrap state updates that aren't immediately visible or critical to user interaction:

```tsx
// ✅ Good: Wrapping expensive list filtering
startTransition(() => {
  setFilteredItems(expensiveFilter(items, query));
});

// ❌ Bad: Wrapping immediate UI feedback
startTransition(() => {
  setInputValue(e.target.value); // This should be immediate
});
```

### 2. **Combine with useDeferredValue**

For even better performance, combine `useTransition` with `useDeferredValue`:

```tsx
import { useTransition, useDeferredValue, useState } from "react";

function SearchComponent() {
  const [isPending, startTransition] = useTransition();
  const [searchTerm, setSearchTerm] = useState("");
  const deferredSearchTerm = useDeferredValue(searchTerm);

  const handleInputChange = (value: string) => {
    setSearchTerm(value); // Immediate update for input field

    startTransition(() => {
      // The deferred value will be used for expensive operations
      performSearch(deferredSearchTerm);
    });
  };

  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => handleInputChange(e.target.value)}
      />
      {isPending && <LoadingSpinner />}
      <SearchResults term={deferredSearchTerm} />
    </div>
  );
}
```

### 3. **Provide Visual Feedback**

Always use the `isPending` flag to show users that something is happening:

```tsx
{
  isPending ? (
    <div className="pointer-events-none opacity-50">
      <ExpensiveComponent />
      <div className="absolute inset-0 flex items-center justify-center">
        <LoadingSpinner />
      </div>
    </div>
  ) : (
    <ExpensiveComponent />
  );
}
```

## Common Pitfalls to Avoid

### 1. **Overusing Transitions**

Don't wrap every state update in a transition. Only use it for updates that are computationally expensive or not immediately critical.

### 2. **Forgetting Visual Feedback**

Always provide some indication when a transition is pending to keep users informed.

### 3. **Mixing Urgent and Non-Urgent Updates**

Be careful not to mix urgent updates (like form inputs) with non-urgent ones in the same transition.

## Performance Comparison

Here's a comparison showing the impact of `useTransition`:

```tsx
// Without useTransition - blocks the UI
function SlowComponent() {
  const [query, setQuery] = useState("");
  const [results, setResults] = useState([]);

  const handleSearch = (term: string) => {
    setQuery(term);
    setResults(expensiveSearch(term)); // Blocks UI
  };

  return <input value={query} onChange={(e) => handleSearch(e.target.value)} />;
}

// With useTransition - keeps UI responsive
function FastComponent() {
  const [isPending, startTransition] = useTransition();
  const [query, setQuery] = useState("");
  const [results, setResults] = useState([]);

  const handleSearch = (term: string) => {
    setQuery(term); // Immediate
    startTransition(() => {
      setResults(expensiveSearch(term)); // Non-blocking
    });
  };

  return (
    <div>
      <input value={query} onChange={(e) => handleSearch(e.target.value)} />
      {isPending && <div>Loading...</div>}
    </div>
  );
}
```

## Conclusion

The `useTransition` hook is a powerful tool for creating smooth, responsive React applications. By carefully separating urgent from non-urgent updates, you can ensure your users always have a snappy, professional experience.

Remember:

- Use it for expensive, non-critical state updates
- Always provide visual feedback with `isPending`
- Combine with other React 19 features like `useDeferredValue` for maximum benefit
- Don't overuse it - not every state update needs to be a transition

Start incorporating `useTransition` into your React 19 applications today and watch your user experience improve dramatically!
